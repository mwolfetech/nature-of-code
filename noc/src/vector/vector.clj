(ns vector.vector 
  (:gen-class)
  (:require [clojure.core.matrix :as m]))


(defprotocol IVector
  (add ^Vector [^Vector this ^Vector that])
  (set ^Vector [^Vector this x] [^Vector this x y] [^Vector this x y z])
  (rem ^Vector [^Vector this amt] [^Vector this x y])
  ;; (rem [x y z]) 
  ;; (sub [x] [x y] [x y z])
  ;; (mult [x] [x y] [x y z])
  ;; (div [x] [x y] [x y z])
  ;; (mag [this]) 
  ;; (mag-sq [this]) 
  ;; (dot [this v])
  ;; (cross [this v])
  ;; (dist [this v])
  ;; (normalize [this v])
  ;; (limit [this, limit])
  ;; (set-mag [this, mag])
  ;; (heading [this])
  ;; (set-heading [this angle])
  ;; (rotate [this, amt])
  ;; (angle-between [this v])
  ;; (lerp [this v amt])
  ;; (slerp [this v amt])
  ;; (refect [this amt])
  (array [this])
  ;; (equals [this x] [this x y] [this x y z])
  ;; (from-angle [a])
  ;; (from-angles [a b])
  ;; (random-2d)
  ;; (random-3d)
  ;; (clamp-to-zero [this])
)
 
(deftype Vector [^:volatile-mutable va]
  IVector
  (add [this that] (m/add! va (.-va ^Vector that)) this)
  (array [this] (double-array (m/clone va)))
  (set [this x] (-> (m/zero-vector 3)
                        (m/mset 0 x)
                        (Vector.)))
  (set [this x y] (-> (m/zero-vector 3)
                        (m/mset 1 y)
                        (m/mset 0 x)
                        (Vector.)))
  (set [this x y z] (-> (m/zero-vector 3)
                        (m/mset 2 z)
                        (m/mset 1 y)
                        (m/mset 0 x)
                        (Vector.)))
  (rem [this amt] (m/emap! #(clojure.core/rem (int %) amt) va) this)
  (rem [this x y] (m/assign! (m/subvector va 0 2) [(clojure.core/rem (m/mget va 0) x) 
                                                   (clojure.core/rem (m/mget va 1) y)]) this)
)

(defn ^Vector make-vector [x y z]
  (m/set-current-implementation :vectorz)
  (Vector. (m/array [x y z]))) 
