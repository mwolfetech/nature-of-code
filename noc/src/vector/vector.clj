(ns vector.vector 
  (:gen-class)
  (:require [clojure.core.matrix :as m]))


(defprotocol IVector
  (add ^Vector [^Vector this ^Vector that])
  (set ^Vector [^Vector this x] [^Vector this x y] [^Vector this x y z])
  (rem ^Vector [^Vector this amt] [^Vector this x y] [^Vector this x y z])
  (sub ^Vector [^Vector this amt] [^Vector this x y] [^Vector this x y z])
  (mult ^Vector [^Vector this amt] [^Vector this x y] [^Vector this x y z])
  (div ^Vector [^Vector this amt] [^Vector this x y] [^Vector this x y z])
  (mag [^Vector this]) 
  (mag-sq [^Vector this]) 
  (dot [^Vector this ^Vector that])
  (cross [this v])
  (dist [this v])
  (normalize [this])
  ;; (limit [this, limit])
  ;; (set-mag [this, mag])
  ;; (heading [this])  
  ;; (set-heading [this angle])
  ;; (rotate [this, amt])
  ;; (angle-between [this v])
  ;; (lerp [this v amt])
  ;; (slerp [this v amt])
  ;; (refect [this amt])
  (array [this])
  ;; (equals [this x] [this x y] [this x y z])
  ;; (from-angle [a])
  ;; (from-angles [a b])
  ;; (random-2d)
  ;; (random-3d)
  ;; (clamp-to-zero [this])
)
 
(deftype Vector [^:volatile-mutable va]
  IVector
  (add [this that] (m/add! va (.-va ^Vector that)) this)
  (array [_] (double-array (m/clone va)))
  (set [_ x] (-> (m/zero-vector 3)
                          (m/mset 0 x)
                        (Vector.)))
  (set [_ x y] (-> (m/zero-vector 3)
                        (m/mset 1 y)
                        (m/mset 0 x)
                        (Vector.)))
  (set [_ x y z] (-> (m/zero-vector 3)
                        (m/mset 2 z)
                        (m/mset 1 y)
                        (m/mset 0 x)
                        (Vector.)))
  (rem [this amt] (m/emap! #(clojure.core/rem  % amt) va) this)
  (rem [this x y] (m/assign! (m/subvector va 0 2) [(clojure.core/rem (m/mget va 0) x) 
                                                   (clojure.core/rem (m/mget va 1) y)]) this)
  (rem [this x y z] (m/assign! va [(clojure.core/rem (m/mget va 0) x)
                                   (clojure.core/rem (m/mget va 1) y)
                                   (clojure.core/rem (m/mget va 2) z)]) this)
  (sub [this amt] (m/emap! #(- % amt) va) this)
  (sub [this x y] (m/assign! (m/subvector va 0 2) [(- (m/mget va 0) x) 
                                                   (- (m/mget va 1) y)]) this)
  (sub [this x y z] (m/assign! va [(- (m/mget va 0) x)
                                   (- (m/mget va 1) y)
                                   (- (m/mget va 2) z)]) this)
  (mult [this amt] (m/emap! #(* % amt) va) this)
  (mult [this x y] (m/assign! (m/subvector va 0 2) [(* (m/mget va 0) x) 
                                                   (* (m/mget va 1) y)]) this)
  (mult [this x y z] (m/assign! va [(* (m/mget va 0) x)
                                   (* (m/mget va 1) y)
                                   (* (m/mget va 2) z)]) this)
  (div [this amt] (m/emap! #(/ % amt) va) this)
  (div [this x y] (m/assign! (m/subvector va 0 2) [(/ (m/mget va 0) x) 
                                                   (/ (m/mget va 1) y)]) this)
  (div [this x y z] (m/assign! va [(/ (m/mget va 0) x)
                                   (/ (m/mget va 1) y)
                                   (/ (m/mget va 2) z)]) this)
  (mag [_] (m/length va))
  (mag-sq [_] (m/length-squared va))
  (dot [_ that] (m/dot va (.-va ^Vector that)))
  (cross [_ that] (Vector.  (m/cross va (.-va ^Vector that))))
  (dist [_ that]  (m/distance va (.-va ^Vector that))) 
  (normalize [this] (m/normalise! va) this)
)

(defn  make-vector ^Vector [x y z]
  (m/set-current-implementation :vectorz)
  (Vector. (m/array [x y z]))) 

(defn normalize [^Vector v]
    (.normalize (Vector. (.array v))))

